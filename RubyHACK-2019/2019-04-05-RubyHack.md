# Ruby Hack 2019

Friday April 5, 2019

Morning Talks

## A Rubyist's Survival Guide to Elixir and Phoenix - Benjamin Porter

Why is scaling ruby hard? The primary way is to scale horizontally, and that can be expensive.
One way to scale is by multi-threading and lots of gems are not thread safe.
Elixir loses out to Go, Rust, etc in CPU intesive tasks UNLESS they're parallelizable
You can do a lot of functional things in Ruby without needing to switch to something like Elixir

Things that elixir does:

- Immutability
  - Elixir forces immutability, which Ruby, and a lot of other languages don't
  - Every time you change variables, you get a copy back, not a mutated original
- Functional!
  - Declarative, rather than imperative
  - Idemoptent, eliminates side effects. Function outputs depend ONLY on function inputs
  - Has really cool compiler implications. If the compiler sees a function called with the same arguments twice, it doesn't have to evaluate the function again, because it already knows the answer.
- Pattern Matching!
- Piping!

A good way to think of the `=` operator is like it used to be in algebra class. It just means that both sides are going to be the same as each other.

## GraphQL Migration: A Proper Use Case for Metaprogramming? - Shawnee Gao

It was a talk about GraphQL. I'm gonna be honest. I didn't pay a TON of attention.

## The Circle of Lifecycle Events - Nelson Wittwer

The lifecycle events and methods:

1. save
1. valid
1. before_validation
1. validate
1. after_validate
1. before_save / before_create
1. create
1. after_save / after_save / after_commit

They're good because they're easy, they're easily testable, and they run at every DB interaction
They're bad because they run at every DB interaction, there is potential for race conditions

> Callbacks should only modify the model they are defined on

If you ABSOLUTELY HAVE to modify multiple models when doing things, you, can wrap them in a transaction and use the transaction in a service object

But seriously, use service objects. There's now been two talks taht have brought this up.
They're great because

- They only have one responsibility
- They're easier to test
- Easier to version
- They can be sidestepped whenever you want
- They're not tied to every database event

They're bad because

- They're not tied to every database event
- They can be sidestepped whenever you want. These can lead to bad data conditions.
- Not vanilla rails

If these models don't live in the same app, you can use a pub/sub architecture with RabbitMQ / Kafka

---

Afternoon Talks

## The Way of the Mentor - Fernando Seror

When you explain things to people outloud, you get a lot more clarity on why/how they work
We are one of the fastest growing occupations in the world, and we need to figure out ways to get people into the profession efficiently
There's a podcast called `The Bike Shed` that is probably worth checking out
The best person to teach a newcomer is the person who has learned that concept most recently
There is a lot of value and a lot of learning that comes from teaching concepts to others and helping to train the next generation of developers

## Using Tests as a Tool to Wrangle Legacy Projects - Jason Swett

Legacy projects sometimes have "bad code" in them, where "bad code" here means hard to understand
The original owner might not be at the company anymore, there are probably bugs, changes take a long time, etc.
Tests can manage those challenges by being a saftey net for changes
But it can be hard, because you might not know what the module you're writing tests around is supposed to do
Obstacles to putting tests on a legacy project:

- Missing test infrastructure?
- Dependencies and tight coupling

A good strategy to start implmenting tests where they don't exist is to start with the "easiest" thing first
Another strategy is to start the "sprout" method. If you have a huge method/function to test, you can break pieces of the functionality out into small methods that are easy to test, and easy to digest.

Characterization tests are cool. Get a failing test in place with everything commented out, and reintroduce lines to the method line by line and update the tests as you go. Kind of like a pseudo-tdd approach.

## ⚡️ Talks

### 1 -

### 2 -

### 3 -

### 4 -

### 5 -

## Reducing Enumerable - An Illustrated Adventure - Brandon Weaver
