# Ruby Hack 2019

Friday April 5, 2019 - "Matz is nice, so we are nice"

Morning Talks

## A Rubyist's Survival Guide to Elixir and Phoenix - Benjamin Porter

Why is scaling ruby hard? The primary way is to scale horizontally, and that can be expensive.
One way to scale is by multi-threading and lots of gems are not thread safe.
Elixir loses out to Go, Rust, etc in CPU intesive tasks UNLESS they're parallelizable
You can do a lot of functional things in Ruby without needing to switch to something like Elixir

Things that elixir does:

- Immutability
  - Elixir forces immutability, which Ruby, and a lot of other languages don't
  - Every time you change variables, you get a copy back, not a mutated original
- Functional!
  - Declarative, rather than imperative
  - Idemoptent, eliminates side effects. Function outputs depend ONLY on function inputs
  - Has really cool compiler implications. If the compiler sees a function called with the same arguments twice, it doesn't have to evaluate the function again, because it already knows the answer.

A good way to think of the `=` operator is like it used to be in algebra class. It just means that both sides are going to be the same as each other.

## GraphQL Migration: A Proper Use Case for Metaprogramming? - Shawnee Gao

## The Circle of Lifecycle Events - Nelson Wittwer

---

Afternoon Talks

## The Way of the Mentor - Fernando Seror

## Using Tests as a Tool to Wrangle Legacy Projects - Jason Swett

## ⚡️ Talks

## Reducing Enumerable - An Illustrated Adventure - Brandon Weaver
